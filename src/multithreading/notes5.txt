
************ Thread Join *****************

if your thread wants to wait until completing some other thread then we should go for join method

* for example ,if your thread t1 wants to wait until completing t2 then t1 has to call t2.join() .
if t1 execute t2.join then immediately t1 will be entered into waiting states until t2 completes .
once t2 complete then t1 can continue it's execution

Join way to announce

1)public void join()     --->Thrown Interrupted Exception
2)public void join(long millisecond)   -->Thrown Interrupted Exception
3)public void join(long millisecond,int microsecond)    --->Thrown InterruptedException

** Note-Every join method throws Interrupted Exception which is checked exception ,hence compulsory we should handle
 this exception either by using try catch or throws exception otherwise we will get compile time error

** for reference -->T15_Thread_Join_Demo

case 3 - if main thread calls join method on child thread object and child thread calls join method on the
main thread object then both threads will wait forever and the program will be strucked (this is something like deadlock)

case 4 - if your threads calls join method on the same thread itself then the program will be strucked (this is something
like deadlock)  ,in this case thread has to wait infinite amount of time

** reference --->T16_Thread_Dead


*****************Thread Sleep *************************
if your thread don't want to perform any operation for a particular amount of time then we should go for sleep
method

** 2 ways of the sleep method declaration**
1)public static native void sleep(long millisecond)            -->throws Interrupted Exception    //not implemented in java
2)public static void sleep(long millisecond,int nanosecond)   -->throws Interrupted Exception

Note = every sleep method throws Interrupted Exception, which is checked exception ,hence whenever we are using
sleep method compulsory we should handle Interrupted Exception either by try catch or by throws keywords otherwise
we will get compile time error

** for reference - T17_Thread_Sleep_1

** A thread can interrupt a sleeping thread or waiting thread by using interrupt method of the thread class---
-->public void interrupt()

** for reference --> T18_Thread_Sleep_2

** Note - whenever we are calling interrupt method if the target thread not in sleeping state or waiting state
then  there is no impact of interrupt call immediately interrupt call will be waited until target thread entered into
sleeping or waiting state if the target thread entered the sleeping or waiting state then immediately interrupt
call will interrupt the target thread.

if the target thread never entered into sleeping or waiting state i it's lifetime then there is no impact of
interrupt call this is the only case where interrupt call will be wasted .

comparison table of yield ,join and sleep method

*****************Synchronize Method in the java ********************

* Synchronized is the modifier applicable only for the method and a block but not for classes and variables

* if multiple thread are trying to operate simultaneously on the same java object then their may be a chance
of data inconsistency problem to overcome this problem we should go for synchronized key word

* if you are blocked declared as synchronized then at a time only one thread is allowed to execute the method
are blocked on the given object so that data inconsistency problem will be resolved

* the main advantage of synchronize keyword is we can resolve the data inconsistency problem but the main disadvantage
of the synchronize keyword is it increases waiting time of the threads and create performance problems ,hence if there is
no specific requirement then it is not recommended to use synchronize keyword.

* internally synchronization is implemented by using lock every object in java has a unique lock ,whenever we are using
synchronized keyword then only lock concept will come into the picture .

* if thread want to execute synchronized method on the given object first it has to get lock of that object once thread got
the lock then it is allowed to execute any synchronized method on that object once method execution completes
automatically thread released the lock

* acquiring and releasing lock internally takes care by JVM and programmer is not responsible for this activity

* while a thread executing synchronized method on the given object the remaining thread are not allowed to execute
any synchronized method simultaneously on the same object , but remaining thread are allowed to execute non synchronized
method simultaneously
example-->
class{
    sync m1()
    sync m2()
    m3()
}
on this object t1 came to execute m1 method (it will start executed)if t2 came to execute the m1 method (waiting state) t3 came to
execute m2 (waiting state) t4 came to execute m3 method (it will get chance immediately)

* lock concept is implemented based on the object but not based on method

* non-synchronized area-- This area can be accessed by any no. of thread simultaneously
* synchronized area -- this area can be accessed by ony one thread at a one time.

example -->
 class{
    synchronized area (){
    where ever we are performing the update operation (add/update/delete/remove) i.e where state of the object changing
    so this area should be inside the synchronized area
    }
    non-synchronized area(){
    where ever object state won't be changed like read operation
    }
 }

example 2 -->
class Reservation(){
     check Availability(){  //non-synchronized
        read operation
     }
     book Ticket(){      //synchronized
        update
     }
}

for reference ----> T20_Thread_Synchronization

